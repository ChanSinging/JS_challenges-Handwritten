### 操作系统

*   **进程**是计算机中正在运行的一个程序，它具有一定的独立性，包括独立的内存空间、文件句柄、环境变量。它可以由一个或多个线程组成。
*   **线程**是进程的基本执行单元，它是CPU调度的最小单位。一个进程可以包含多个线程，这些线程共享该进程的资源，如内存、文件句柄等。每个线程有自己的堆栈，用于存储局部变量和调用栈等信息。

#### 进程和线程的通信有了解吗

*   管道通信，管道通信是在内存区域开辟一片内存空间（缓存区），进程1将交换的数据拷贝到缓存区中，进程2可以读取到
*   消息队列通信：消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类
*   信号量通信：是一个计数器，用来控制对多个进程对共享资源的访问。防止某一个进程在访问资源时，其他进程也访问
*   信号通信：操作系统通过信号来通知进程系统中发生了某种预先规定好的事件 (一组事件中的 它也是用户进程之间通信和同步的一种原始机制
*   共享内存通信：是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，可以多个进程一起访问

## 计算机网络

TCP/IP的**五层协议**

*   应用层
    *   为应用进展提供服务。应用层定义了   HTTP网络协议，FTP协议，DNS域名查询
    *   数据格式：数据
*   传输层
    *   为两台主机提供通信服务  有两种协议TCP、UDP ，封装TCP
    *   数据格式：数据段
*   网络层
    *   为两台主机提供服务，选择合适的路由将数据传递到主机
    *   数据包
*   数据链路层
    *   将上层的IP封装成帧投和帧尾
    *   帧
*   物理层
    *   确保数据在各种数据媒介传递
    *   数据格式：比特

#### 七层协议

*   ![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604025489154-966a96f5-1c8e-4d03-b9f9-f51250f63a22.png?x-oss-process=image%2Fresize%2Cw_736%2Climit_0)

#### TCP与UDP的区别

*   是否连接：udp是无连接的，tcp是面向连接的
*   是否可靠：udp不可靠传输，不使用流量控制和拥塞控制；tcp是可靠传输（保证数据顺序和正确性）
*   连接对象个数：支持一对一，一对多和多对一；tcp只能一对一通信
*   传输方式：udp是面向报文；tcp是面向字节流
*   使用场景：udp适用于实时应用，例如视频会议、直播，适用于要求可靠传输的应用；tcp适用于准确性高的场景

#### TCP和HTTP的区别

*   传输控制协议，另一个是超文本传输协议，一个作用于传输层，一个作用于应用层
*   功能不同：TCP提供了可靠的、面向连接的数据传输，确保数据的有序性、完整性和不丢失；HTTP则是一种规定了客户端和服务器之间如何请求和响应数据的协议
*   是否面向连接的：TCP是面向连接的，需要三次握手；HTTP是无连接的

#### 为什么udp适用于实时应用

*   低延迟：UDP不需要建立连接和维护状态，因此不会出现TCP中的握手和拥塞控制等开销
*   较小的头部开销：UDP头部相比TCP更小，只有8字节，而TCP头部则有20字节
*   无需保证数据可靠性：UDP不保证数据的可靠性和顺序性，因此在传输过程中可能会出现丢包或乱序的情况，适合直播流

#### TCP在在网络分层中扮演什么角色

在 TCP/IP 参考模型中，TCP 位于传输层

1.  提供可靠的数据传输：TCP 使用确认、重传和流量控制等机制来确保数据的可靠性。它会将数据分割成小的数据包，并在接收端重新组装这些数据包，以确保数据按正确的顺序到达，并且没有数据丢失或损坏。
2.  建立和维护连接：TCP 通过三次握手的过程建立连接，并通过四次挥手的过程安全地关闭连接。连接的建立和维护使得数据可以在两台计算机之间可靠地传输。
3.  提供流量控制和拥塞控制：TCP 使用滑动窗口机制来控制数据的流量，确保发送方不会发送过多的数据导致接收方无法处理。此外，TCP 还具有拥塞控制机制，用于控制网络中的拥塞情况，以避免网络过载。

#### 谈一谈TCP的拥塞控制

是一种机制，用于在网络中避免有过多的数据流量导致网络拥塞。拥塞控制通过**动态调整发送数据的速率来**控制网络，以便在网络峰值之前避免拥塞

有一些特性：

*   慢启动。当开启TCP连接时，发送方会以指数增长的方法增加发送窗口的数量，避免一次性过快地发送全部数据
*   拥塞避免（Congestion Avoidance）：一旦发送方的拥塞窗口达到某个阈值（拥塞窗口大小），发送方就会采用线性增加的方式逐渐增加拥塞窗口的大小，而不是指数增加。这样可以避免发送过多的数据导致网络拥塞。
*   快速重传：当检测到丢包时，立即回传丢失的数据包
*   快速恢复（Fast Recovery）：当发送方接收到重复的确认（ACK）时，表明网络中的某个数据包丢失，发送方会减小拥塞窗口的大小，并采用拥塞避免算法进行调整。这样可以更加精确地控制数据发送的速率，避免拥塞的发生。

**网络接口层**

*   采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部就是干这个
*   MAC头部是以太网使用的头部，他包含接收方和发送方的MAC地址信息，通过ARP获取对方的MAC地址

**总结**

每一层的封装格式

经典问题

http1/2/3 https和http区别\[ 浏览器缓存  协商缓存强制缓存]

#### HTTP请求报文的结构是什么样的？

1.  请求行(Request Line)：包含请求方法、请求目标和HTTP协议版本
2.  请求头部（Request Header）：包含关于请求的附加信息，每个头部字段都由字段名和字段值组成，中间用冒号分隔。

    1.  常见的请求头部：Host、User-Agent、Content-Type、Authorization
3.  请求体：携带的资源，比如表单提交数据和JSON数据库

##### 为什么 HTTP 协议是无状态的，什么是无状态的

http是无状态的，意味着服务器在处理客户端时，不会保留先前请求的任何状态信息。每个请求是独立

这样设计的原因是

1.  简化服务器：无状态性使得服务器不需要维护大量的连接信息和状态信息，从而减少了服务器的负担和复杂性
2.  可伸缩性：无状态性允许服务器在多台服务器之间进行负载均衡
3.  缓存和代理：代理服务器和缓存服务器能够更有效地处理请求

当然了引入cookie和session，通过使用Cookie，服务器可以在客户端存储一些状态信息；Session机制则是在服务器端存储用户的状态信息，并为每个会话分配一个唯一的标识符。

#### **HTTP与HTTPS有哪些区别**

*   HTTP是超文本传输协议，信息是明文传输，存在安全风险问题。HTTPS是解决HTTP不安全的缺陷，在TCP和HTTP网络层<u>加入SSL/TLS加密协议</u>，是得报文更加加密传输
*   HTTP连接建立相对简单，TCP三次握手之后便HTTP的报文传输。而HTTPS在三次握手之后，还需要进行<u>SSL/TLS的握手</u>，才可进行加密报文传输
*   默认的端口号不一样，HTTP是80，HTTPS是443
*   HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

#### HTTPS的安全传输协议TLS/SSL

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png?x-oss-process=image%2Fresize%2Cw_553%2Climit_0)

TLS/SSL是结余TCP和HTTPS之间的一层安全协议。他的实现是基于三类算法：散列函数hash、对称函数和非对称函数

*   散列函数hash：可以验证信息的完整性 MD
*   对称函数：采用协商的秘钥对数据加密
*   非对称函数：实现身份认证和秘钥协商

#### HTTPS加密过程

有两种**对称加密**和**非对称加密**。

HTTPS在进行数据传输之前，需要客户端与服务器之间进行一次握手，在握手过程中将确认双方加密传输数据的密码信息。该过程中采用TLS/SSL协议，TLS/SSL协议是一种加密通道的规范。TLS/SSL采用了非对称加密，对称加密以及HASH算法

*   客户端向服务端发起连接请求，并告知服务器将建立HTTPS连接，此时客户端同时将自己支持的加密算法带给服务端
*   服务端收到这套加密算法的时候，和自己支持的加密算法进行对比，符合， 选出一组加密算法与HASH算法，服务器将自己的身份信息以证书的形式发回给浏览器
*   客户端收到网站证书
    *   使用根证书验证颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致
    *   浏览器会生成一串随机数的密码(RSA签名)，并用证书中提供的公钥加密
    *   使用约定好的HASH算法计算握手消息，并使用生成的密码对消息进行加密，发送给服务端
*   服务端接收到客户端发来的数据之后，首先，使用自己的私钥将信息解密取出密码，使用密钥解密浏览器发来的握手消息，并验证HASH是否与客户端来的一致，将加密后的内容发给客户端
*   客户端收到消息之后，解密并计算握手消息的HASH，如果与服务端发来的HASH一致，握手结束

#### HTTPS为什么要用非对称加密和对称加密相结合？

*   强大的安全性：非对称加密（公钥加密）提供了强大的安全性
*   效率和性能：对称加密（密钥加密）是一种高效的加密方式，它使用相同的密钥进行加密和解密
*   密钥交换的安全性：使用非对称加密算法进行密钥交换可以确保密钥的安全性。

##### HTTPS什么时候用对称加密，什么时候用非对称加密，为什么不能一直使用非对称加密

*   非对称加密的性能会比对称加密差一些，在性能有限和HTTPS 涉及到大量的接口、数据等非常频繁的操作行为下，优先选择对称加密算法
*   对称加密算法很安全性更高。

对称算法是：

> 使用同一个秘钥来进行加秘和解密，放到具体场景，也就是通讯双方使用同一个秘钥，一方加密发送信息，另一方解密密文获取信息。

非对称算法是：

> 通过特殊手段，实现的一种加密方式，这种方式能够通过一个公钥进行加密，然后通过私钥进行解密，而公钥与私钥不同，因此成为非对称

##### HTTPS安全的握手过程

是一种基于加密的安全版本的 HTTP，用于保护在网络上传输的数据的安全性和完整性。HTTPS 使用了 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）协议来加密通信内容

主要是完成三件事，客户端向服务端索要公钥、双方协商产生会话秘钥、双方采用会话秘钥通信。

*   客户端发送连接请求：客户端（浏览器）向服务器发送一个连接请求，请求建立一个加密连接
*   服务端发送证书：服务器会将自己的数字证书发送给客户端。数字证书包含服务器的公钥，公钥是有第三方机构签署，来证明服务端
*   客户端验证证书：验证服务器的数字证书的合法性和有效性
*   客户端生成随机密钥：客户端生成一个随机的对称密钥，用于后续的数据加密和解密
*   客户端使用服务端的公钥加密：客户端使用**服务器的公钥**加密生成的随机密钥，然后将加密后的随机密钥（"premaster secret）发送给服务器
*   服务端使用私钥解密：服务器使用自己的私钥对客户端发送的加密随机密钥（premaster secret）进行解密
*   **客户端就绪：** 客户端发送经过共享密钥 **KEY**加密过的"finished"信号。
*   **服务器就绪：** 服务器发送经过共享密钥 **KEY**加密过的"finished"信号。
*   握手完成

##### 密钥和公钥的区别

公钥是一对非对称密钥中的一个部分。它可以公开分享给任何人，并用于加密数据

私钥是与公钥配对的非对称密钥的另一部分。它必须严格保密，并只有拥有私钥的一方可以使用它来**解密从公钥加密的数据**。

##### 服务器返回的证书是什么

CA（Certificate Authority）是证书颁发机构的缩写。它是一种可信任的实体，负责验证和签发数字证书。数字证书是用于加密通信和**身份验证**的安全性工具，其中包含公钥和与之关联的身份信息。

*   公钥
*   证书持有人的身份信息
*   颁发机构的签名

当用户访问一个使用CA数字证书保护的网站时，网站会向用户发送其数字证书。用户的浏览器会验证证书的有效性，包括验证签名、检查证书的有效期等。如果验证成功，浏览器会使用证书中的公钥来加密数据，确保与网站之间的通信是安全的。

#### HTTPS 解决了 HTTP 的哪些问题？

*   http存在窃听风险，篡改风险，冒充风险
*   HTTPS在http与TCP之间加入了`SSL/TLS`协议

#### **http1.1 和http1.0之间有哪些区别**

*   连接方面的区别：`http1.1`默认使用持久连接，而`http1.0`默认非持久连接。`http1.1`通过持久连接来使用多个http请求复用用一个TCP连接，来避免使用非持久连接时需要建立连接的时延
*   资源请求的区别：在`http1.0`存在浪费宽带的现象，例如只需要对象的某一部分，而服务器将整个对象送过来，`http1.1`则在请求头中引入了`range`区域，允许只请求资源的某个部分，即返回码是`206(partial content)`，方便了开发者自由的选择
*   缓存方面区别：`http1.0`中使用header里的`Cache-control` 和`Expires`来作为缓存判断的标准
    *   `http1.1`有更多的缓存控制策略`Etag` `If-modified-Since` `If-None-Match` 很更多的策略
*   `http1.1`新增了host字段，用来指定服务器的域名。因为http1.0任务每台服务器绑定了唯一的IP地址，因此请求信息中没有传递主机名（hostname）
    *   随着虚拟主机的发展，一台服务器上有对个虚拟主机，并且他们共享一个ip地址。因此有host字段，将请求发往同一台服务器上
    *   http1.1新增了很多方法，如put、head、option

##### 一个 TCP 连接可以对应几个 HTTP 请求？

如果是维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的

#### HTTP2.0做了什么优化

*   头部压缩：如果发送多个请求，他的头是相似的，协议会帮助清除相同的部分。采用`HPACK` 算法实现
*   数据流：HTTP/2使用了数据流的概念，因为 HTTP/2的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。
*   二进制格式：全面采用二进制。HTTP2全面采用二进制协议，头信息和数据体都是二进制，统称为“帧”。可以分成头信息帧和数据帧，帧的概念是实现多路复用的基础。
*   并发传输（**多路复用**）
    *   HTTP/2引入了多路复用功能，允许在单个TCP连接上同时发送多个请求和接收响应。在HTTP/1.1中，每个请求都需要建立一个独立的TCP连接，而HTTP/2通过复用连接，避免了建立多个连接的开销。这样可以减少延迟，提高效率
*   服务器主动推送资源：HTTP/2 允许服务器未经请求，主动向客户端发送资源。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。

#### HTTP2的多路复用是什么

通过 Stream 这个设计，**多个 Stream 复用一条 TCP 连接，达到并发的效果**，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。

*   1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；
*   Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；
*   多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，多个 TCP 报文构成

#### 多路复用是怎么实现的

*   在HTTP2中，同域名下的网站都在单链接上完成，同一个域名占用一个TCP连接，使用一个连接并行发送多个请求和响应
*   单个连接可以承载多个双向数据流，可以交错发送和接受
*   数据流是以消息的形式发送，而消息又是由一个或者多个帧组成，多个帧交错乱序发送，因为帧可以重新组装
*   **并行流**：在 HTTP/2.0 中，可以在同一连接上创建多个流，每个流都有一个唯一的标识符。这些流可以并行传输，而不会阻塞其他流的传输

#### HTTP3有哪些升级

基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输

*   无队头阻塞：同一物理连接上可以有多个独立的逻辑数据流，实现数据流的单独传输，解决了TCP的队头阻问题
*   更快的连接建立：
*   连接迁移

![HTTP/1 \~ HTTP/3](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png)

#### 缓存在http各个版本的作用机制

*   http1.0上使用的是header的`Expire`作为缓存判断的依据
*   http1.1是使用`etag` `If-Match`  `If-None-Match` 可供选择的更多缓存头来控制缓存策略
    *   服务器可以发送`Cache-Control`字段来定义缓存策略
    *   客户端可以发送`If-None-Match`和`If-Modified-Since`
*   http2.0是建立在HTTP/1.1的基础上，保持不变

**HTTP/1.1的优点和缺点**

*   简单 http基本的1报文格式是`header+body`, 头部信息也是key-value形式，易于理解
*   *灵活和易于扩展*
    *   http协议的各类请求方法，url uri的组成要求没有被固定死，允许自信添加和扩充
    *   https 在网络传输层加了ssl/tls安全传输层，除了三次挥手，还需要ssl/tls层的挥手
    *   http1.0和http/2.0 是使用tcp传输协议，而http3.0是使用udp协议
*   跨平台，超文本传输协议适用于各大平台，pc客户端，浏览器，小程序，app，满足互联网时代的各种需求。

#### 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？

有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接，不同浏览器有区别。

***

#### **HTTP** **常见的状态码**

*   1xx，提示信息，表示目前是协议处理的中间状态，需要后续的操作
*   2xx，成功，报文已经收到被正确处理
*   3xx，重定向，资源位置发生变动，需要客户端重新发送请求
*   4xx,   客户端错误，请求报文有误，服务器无法处理
*   5xx，服务器错误，服务器在处理是内部错误

`1xx`类不常用

`2xx`类表示服务器成功处理了客户端的请求

*   `200 OK` 是表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
*   `204 no content` 也是成功。但是响应头没有body数据
*   `206 partial content`  是应用于http分块下载或断点续传

`3xx`类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取数据，也就是**重定向**

*   `301 moved permanent`表示永久重定向，说明请求的资源已经不存在，需要改用新的URL重新访问
    *   换域名，重定向到新域名
*   `302 found` 表示临时重定向，说明请求的资源还在，需要另一个URL来访问
    *   场景：访问404页面重定向；当我们在做活动时，登录到首页自动重定向，进入活动页面
*   `303 See other` 表示请求对应的资源存在这另外一个url，使用get方法定向获取请求的资源
*   `304 Not Modified ` 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，换句话说是告诉客户端可以继续使用缓存资源，用于缓存控制
    *   协商缓存

`4xx`类状态码表示**客户端发送的报文有误**，服务器无法处理，也就是错误码的含义

*   `400 bad request` 表示客户端请求的报文有错误，但只是笼统的错误
*   `401 unauthorized`  该状态表示发送的请求需要通过HTTP认证    登录失败，服务器配置导致，
*   `403 Forbidden` 表示服务器禁止访问资源，并不是客户端的请求出错，服务端禁止访问
*   `404 Not Found` 表示请求的资源在服务器上不存在或未找到，无法提供给客户端，资源在服务端找不到

`5xx`类状态码变式客户端请求报文正确，但是**服务器**处理时内部发生了错误，属于服务器的错误码

*   `500 internal server error`笼统通过的错误码
*   `501 not implemented` 表示客户端请求的功能还不支持
*   `502 bad Gateway` 通常是服务器作为网关或代理是返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误
*   `503 service unavailable` 表示服务器当前很忙，暂时无法响应客户端，

***

#### DNS解析的详细过程

*   首先在浏览器缓存中查找对应的IP地址，有直接返回，没有下一步（递归查询）
*   发送请求到**本地DNS服务器**，到本地服务器缓存中查找，有返回，没有下一步（迭代查询）
*   本地DNS服务器向**根域名服务器**发送请求，根域名会返回一个所查询过的**顶级域名服务器**
*   本地DNS服务器向**顶级域名服务器**发送请求
*   本地DNS服务器向**权威域名服务器**

***

#### **HTTP有哪些缓存技术**

HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。

*   强缓存：只要浏览器判断`Cache Control\Expire` 如果缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
    *   强缓存是利用两个HTTP响应头部实现，表示资源在客户端缓存的有效期
*   协商缓存：判断`if modefied since\if none match `

#### **Get和Post请求的总结**

get从服务器获取指定的资源

post是请求负荷对指定的资源做出处理，post请求携带数据的位置一般携带数据的位置写在报文body中，

区别如下：

*   get是请求获取指定的资源；方法是安全、幂等、可被缓存的
*   post的语义是根据请求负荷对指定的资源做出处理、具体的处理方式视资源类型而不同
    *   会修改服务器的资源，不是安全的，并且多次提交数据会创建多个资源，不是等幂的。随意浏览器不会缓存POST请求

**请求回来的资源如何判断是js还是css还是html**
通过查看响应头的content-type标头来确定资源的类型。有指定的媒体类型（如HTML、CSS、JS）
`const contentType = response.headers.get('Content-Type');`

***

#### TCP三次挥手和四次挥手

##### 三次握手

*   一开始客户端是处于close状态。服务端是主动监听某个端口
*   第一次握手：客户端给服务端发一个SYN报文，并指明客户端初始序列号ISN，之后客户端处于SYN-SENT状态
*   第二次握手：服务端收到SYN报文后，将自己的SYN作为应答，将客户端的ISN+1作为ACK值，表示自己收到客户端的SYN，此时服务器处于SYN\_REVD状态
*   第三次握手：客户端收到SYN报文，会发送一个ACK报文，当然也是一样的，服务器的ISN+1作为ACK的值，表示已经收到服务器的SYN报文，客户端和服务端处于established，双方建立联系。
*   三次握手的简历连接是相互确认初始序号的过程，告诉对方，什么样的报文能够被正确接受

##### 四次挥手

*   双方都处于establish状态，假如客户端发起请求
*   第一次挥手：客户端会发送一个FIN报文。报文中会指定一个序列号
*   第二次挥手：服务器收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号，表明已收到客户端的报文，此时服务器处于close\_wait状态
*   第三次挥手：如果服务器也想断开连接，和客户端第一次挥手一样，发给FIN报文，且指定一个序列号。此时服务器处于last ack状态
*   第四次挥手：客户端收到fin状态，一样发送ack报文作为应答，且把服务端的序列号值+1作为自己ACK报文的序列号值，此时客户端处于TIME\_WAIT状态。需要过一段时间一确保自己的ACK报文之后会进入close的状态。服务器收到ack报文后，就处于关闭连接们出于closed状态。

***

##### 为什么是三次握手？不是两次、四次？

*   三次握手才可以阻止重复历史连接的初始化（主要原因）
    *   因此，要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。
*   TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素
    *   当客户端发送携带「初始序列号」的 `SYN` 报文的时候，需要服务端回一个 `ACK` 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应。
    *   服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。
*   避免资源浪费

##### 对头阻塞

因为当顺序发送的请求序列的一个请求因为某种原因被阻塞了，导致后续的请求无法正常的前进，客户端迟迟收不到消息。这是对头阻塞，好比上班堵车。

***

#### HTTP的请求方式

*   get
*   post
*   put   PUT方法主要用来传输文件，就像FTP协议的文件上传一样。
*   head  HEAD请求主要用来获取报文首部
*   delete  来删除某个资源

#### get和post两种请求的区别

*   应用场景：GET是一个等幂的请求，一般GET请求不会对服务器有影响，POST对服务器有影响  比如注册用户
*   缓存 ： get有缓存   POST没有缓存
*   安全性：get请求相对安全，参数放在url内，相对于POST请求不安全，因为url信息会保存在浏览器
*   请求长度限制： get的长度有限制
*   参数类型：post传递有更多参数的要求

***

### WebSocket

#### 即时通讯的实现: 短轮询、长轮询、SSE和 WebSocket 间的区别?

##### 长轮询

长轮询的基本思路:首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。

SSE的通讯方式

#### Websocket是什么

WebSocket，是一种网络传输协议，位于`OSI`模型的应用层。可在单个`TCP`连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅

优点

*   更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
*   较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部

***

#### CDN原理

内容分发网络，

1.  **缓存内容分发**：CDN 提供商会在全球各地的服务器节点上==缓存静态和动态内容==，例如网页、图像、视频、文件等。这些服务器节点分布在不同的地理位置，使得内容能够更接近用户，从而提供更快的访问速度。
2.  **就近访问**：当用户请求访问一个内容时，CDN 会通过智能路由技术将用户的请求导向最接近用户的服务器节点
3.  **负载均衡**：CDN 通过智能路由和负载均衡技术，将用户请求分配到最合适的服务器节点上

如果CDN没有找到想要的内容需要往原服务器
