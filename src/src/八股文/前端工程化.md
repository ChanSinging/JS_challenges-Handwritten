# 前端工程化

#### 为什么要打包

*   比如vue浏览器无法识别的，是为了将文件转化成浏览器可以识别的文件 HTML ×

    *   前端项目打包是为了将开发环境中的源代码、资源文件和依赖库等文件打包成一个或多个静态资源文件，便于在生产环境中部署和使用。
    *   通常打包后的文件可以通过HTTP服务器进行访问和下载，以提高访问速度和减少带宽消耗。
    *   打包还可以对代码进行压缩、优化和混淆等操作，以减小文件的体积和提高加载速度，同时也可以避免代码被盗取和恶意利用。
    *   打包过程中还可以进行代码分割、按需加载、缓存等优化操作，以提高应用的性能和用户体验。

    常见的前端项目打包工具有Webpack、Rollup、Parcel等，它们可以根据配置文件对项目进行打包，将多个JS、CSS、图片等资源文件进行合并、压缩和优化，最终生成一个或多个静态资源文件，以便于在生产环境中使用。

    总之，前端项目打包是将源代码和资源文件进行优化和整合的过程，可以提高项目的可维护性和性能，并方便部署和使用。

#### 前端脚手架有哪些功能

脚手架是一个自动化构建工具，用于快速创建和配置项目的基础结构。它可以帮助开发者快速搭建一个项目，提供了一些基础配置和目录结构，使得开发者可以专注于业务逻辑的实现，而不用花费太多时间在项目的搭建和配置上。脚手架通常包括以下功能：

*   项目结构：脚手架提供了一些基础的目录结构，包括src、public、assets等目录，使得开发者可以快速开始项目的开发。
*   模板引擎：脚手架通常会提供一些预设的模板，例如HTML模板、CSS模板、JS模板等，使得开发者可以快速创建文件并进行开发。
*   依赖管理：脚手架会自动安装和配置一些常用的依赖项，例如webpack、babel、ESLint等，使得开发者可以快速开始项目的开发和构建。
*   配置文件： 例如webpack配置 vite配置。使得开发者可以根据自己的需求进行配置，从而满足不同的开发需求。

### Webpack  <https://juejin.cn/post/6844903892031897608#heading-8>

Webpack是是一个现代化的JavaScript应用程序打包工具。基于模块化打包的工具。 核心是模块化。它将应用程序拆分为一个个模块，每个模块都有自己的代码、依赖和导出。

他能自动化处理模块，webpack把一切当成模块，当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有模块打包成一个或者多个bundle。

*   模块化：Webpack将应用程序拆分为一个个模块，使得代码更易于维护和扩展。
*   代码拆分：将代码拆分成多个捆绑包，
*   插件系统：有强大的插件系统
*   配置文件：Webpack可以通过配置文件进行配置

#### Webpack的基本配置

*   每次修改文件之后，都要使用 `webpack 入口文件路径 输出文件路径`来对文件进行处理，使用起来比较**繁琐**
*   首先在项目根添加添加webpack的配置文件`webpack.config.js`
*   在Webpack配置文件里面配置处理的入口文件和输出文件
*   在配置完成后，在调试台通过webpack命令来对文件进行处理

```js
const path = require('path')
module.exports = {
    entry:path.join(__dirname,'./src/main.js'),

    output:{
        path:path.join(__dirname,'./dist'),
        filename:'bundle.js'
    }
}
```

#### Webpack打包流程

1、初始化参数：从shell文件和配置文件，读取`webpack`的配置参数；

2、开始编译：启动`webpack`，利用上面得到的参数创建`Compiler`对象并开始解析项目；

3、编译模板：从入口文件（`entry`）开始解析，并且**找到其导入的依赖模块**，递归遍历分析，形成依赖关系树；Babel

4、完成模板编译：对不同文件类型的依赖模块文件使用对应的`Loader`进行编译，最终转为`Javascript`文件；

5、整个过程中`webpack`会通过发布订阅模式，向外抛出一些`hooks`，而`webpack`的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的

#### Webpack支持哪种规范

*   Common JS
*   ES module
*   AMD
*   UMD

#### Sass文件在webpack中的编译打包过程是怎么样的？

1.  安装相关的Loader和Plugin
2.  在Webpack配置文件中，配置相关的Loader和Plugin。比如：

```js
test: /\.scss$/,
        use: [
          'style-loader', // 把css样式写入html的<style>标签中
          'css-loader',   // 解析.css文件，转化为JS模块
          'sass-loader'   // 把sass/scss文件编译成.css文件
        ]
```

1.  编译scss：sass编译器将scss编译为css
2.  css-loader解析：根据css-loader对css文件进行加载并解析其中的
3.  style-loader工作：将css样式插入html文件

#### Webpack 的 loader 和 plugin, 接触过哪些 plugin 的 hooks

1.  Loader 是 Webpack 中一个非常重要的概念，它用于**将各种类型的文件转换成** Webpack 可以处理的模块。例如，将 ES6/7/8 转换成 ES5，将 TypeScript 转换成 JavaScript，将 SCSS 转换成 CSS 等等。Webpack 配置中的 module.rules 用于配置 Loader，每个 Loader 可以对应一个或多个文件类型，并且支持链式调用。例如，下面是一个将 ES6 转换成 ES5 的 Loader 配置示例：
2.  Babel
3.  Plugin 是 Webpack 中一个非常重要的概念，它可以用于**扩展** Webpack 的功能。Webpack 在打包过程中会触发各种事件，Plugin 可以监听这些事件，在相应的事件触发时执行自己的逻辑。例如，可以使用插件压缩 JavaScript、优化 CSS、拷贝静态资源等等。Webpack 配置中的 plugins 用于配置 Plugin，每个 Plugin 可以实现一个或多个功能。例如，下面是一个将 CSS 压缩的 Plugin 配置示例：

##### 常见的loader：

*   css loader 加载css 支持模块化
*   file loader 把文件输出到一个文件夹中，在代码中通过相对的URL去引用输出的文件
*   url loader 和file loader相似，能在很小的情况以下间文件注入到代码

##### 常见的plugin

*   define-plugin 定义环境变量
*   html-webpack-plugin 简化html文件创建

#### webpack中css-loader,style-loader,scss-leader的各自作用

*   Css-loader的作用主要是解析css文件中的@import和url语句，处理css-modules，并将结果作为一个js模块返回。
    *   将多个CSS文件的样式内容以字符串形式拼接在一起，并将其作为js模块的导出内容
*   style-loader的作用就是将结果以style标签的方式插入DOM树中。
*   执行顺序是先css-loader将css解析成一个js模块返回，再style-loader将css插入到DOM

#### loader和plugin的不同

*   loader是加载器。webpack视一切文件为模板，但是webpack原生只是解析js文件，如果将其他文件特打包得用loader
*   plugin是插件

#### Webpack rollup parcel的区别

rollup是支持小型的项目，适用于基础库的打包vue d3；将所有文件打包进一个文件，使用treeshake去除无用代码，但是他没有webpack那种按需加载，代码分割的功能，适合库开发

webpack支持大型项目，适用复杂应用的开发，功能全，loader和plugin

parce适用于简单实验

#### 新技术 SWC

speedy Web Compiler 他是比Bable快20倍

```js
//webpack.config.js
module:{
    rules:[
        {
            test:/\.ts$/
            use:"swc-loader"  // 
        }
    ]
}
```

#### 如何提供Webpack打包速度

*   dlI: 采用webpack的 DlIPlugin 和 DIlReferencePlugin 引入dll，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间
*   利用缓存：webpack.cache、babelloader.cacheDirectorv、利用缓存提高rebuild速度
*   利用treeshaking和scope Hoist来剔除多余代码
*   HappyPadk.cache多线程加速编译

#### webPack如何性能优化

*   压缩代码
*   确保使用最新的版本
*   避免在项目中引入不必要的库和模板，这需要引入所以需要的
*   使用 `DllPlugin` 和 `DllReferencePlugin` 来分离第三方库，以便在后续的构建中减少重复构建和提高构建速度
*   使用 `HappyPack` 将任务分发给多个 worker 线程以并行构建
*   使用 `cache-loader` 和 `hard-source-webpack-plugin` 等缓存插件来避免重复构建
*   通过 `Tree Shaking` 和 `Scope Hoisting` 等技术来减少代码体积和提高构建速度
*   合理使用 `splitChunks` 来优化代码拆分，减少重复代码，减小 bundle 大小

#### webpack来优化性能

*   利用CDN网络加速
*   压缩代码，可以webpack的插件
*   和上面一样，都是能优化webpack的操作

#### 前端项目如何做tree-shake，为什么做tree-shake

tree-shaking 是一种消除无用代码的方式，tree-shaking 虽然能够消除无用代码，但仅针对 ES6 模块语法，因为 ES6 模块采用的是静态分析，从字面量对代码进行分析

#### Webpack如何配置tree shake

#### Webpack如何实现热更新

*   在webpack的watch模式下，文件系统某个文件发生修改，webpack监听到文件变化，重新编译打包
*   webpack-dev-server和webpack之间的接口交互，这一步是webpack-dev-middleware调用webpack暴漏的API对代码变化的监控
*   webpack-dev-server对文件一个监控
*   webpack-dev-server代码的工作，该步聚主要是通过 sockjs (Wepack-dev-server的依赖)在览器端和服务端之间建一个websocket长连接，将webpack编译打包的各个阶段的状态信息告知浏览器

<https://juejin.cn/post/6968262966604988429#heading-3>

##### vite在做按需引入的优雅方法  <https://juejin.cn/post/6992131592873312263>

#### Webpack实战

##### 前端项目有中文包和英文包，如果不想同时加载多个语言包，webpack打包上要如何做

> 可以使用Webpack的代码分割（code splitting）功能来实现。Webpack的代码分割允许你将代码拆分为多个文件，使得在运行时只加载需要的部分。

1.  我们将主要的应用程序代码和语言包分别配置为不同的入口文件（`main.js`、`chinese.js`、`english.js`）。然后，使用Webpack的 `splitChunks` 配置将 `locales` 目录下的代码（即语言包）拆分为一个独立的文件。
2.  接下来，在应用程序中根据需要动态加载语言包文件。你可以使用Webpack提供的动态导入（dynamic import）

```javascript
 entry: {
    main: './src/main.js',
    chinese: './src/locales/chinese.js',
    english: './src/locales/english.js'
  },
optimization: {
    splitChunks: {
      cacheGroups: {
        locales: {
          test: /locales/,
          name: 'locales',
          chunks: 'all',
          enforce: true
        }
      }
    }
```

#### **Vite Webpack的区别**

##### Vite的优点

*   Webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。 而Vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译，所以打包速度会有明显的提升。
*   这实际上是让浏览器接管了打包程序的部分工作：`Vite` 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。
*   vite 第一次加载后，还是

##### vite的优点

*   启动速度快，只启动一台静态页面的服务器，对文件代码不打包，只需要进行一些初始化的操作，其余全部交由浏览器处理，利用浏览器性能。
*   热更新快，在 Vite 中，HMR 是在原生 ESM 上执行的，编辑一个文件时，Vite只需要精确地使用已编辑的模块与其最近的HMR边界之间的链失活。

##### webpack的优点

*   由于 dev 启动过程中已经完成整个打包操作，直接将构建好的首屏内容发送给浏览器，不存在性能问题；
*   懒加载也不存在问题

#### Vite配置

<https://cn.vitejs.dev/guide/static-deploy.html>  official doc

```js
// 有哪些基本的配置  
root: process.cwd(), // 项目根目录（index.html 文件所在的位置）,
base: '/', // 开发或生产环境服务的公共基础路径 配置引入相对路径
mode: 'development', // 模式
build: // 构建
plugin: //插件
server:
```

```js
import { defineConfig } from 'vite'
import path from 'path'
export default defineConfig({
  build: {
    lib: {
      entry: path.resolve(__dirname, 'lib/main.js'),
      // umd 形式的命名空间
      name: 'MyLib',
      fileName: (format) => `my-lib.${format}.js`
    },
    rollupOptions: {
      // 确保外部化处理那些你不想打包进库的依赖
      external: ['vue'],
      output: {
        // 在 umd 构建模式下为这些外部化的依赖提供一个全局变量
        globals: {
          vue: 'Vue'
        }
      }
    }
  }
})
```

**按需引用的配置**

```js
// vite.config.js
import typescript2 from 'rollup-plugin-typescript2'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...typescript2(),
      apply: 'build',
    },
  ],
})

```

#### 模块化开发：通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。

#### Vite打包项目引出CSJ和ESM是什么？

CSJ是真正的模块化解决方案，最早从node

> 特点：模块加载`require`就是代码执行；所有代码运行在模块作用域中，不污染全局

ESM是ES6标准中的模块规则，统一浏览器和服务端

> 特点：支持import和export  支持esmodule，&#x20;

#### ESmodule和CommonJS有什么区别

1.  语法不同： ESModule是原生支持的JavaScript模板系统，使用import/export 关键字实现模板的导入和导出。而CommonJs是Node最早引入的模板方案，采用**require**和**module.export**实现模板的导入和导出
2.  加载方式关系不同：
    1.  ESM是静态导入，在编译时解析依赖，因此可以在编译时进行优化，比如*树摇*（删除未使用的代码）
    2.  CommonJS 是动态导入，在运行时解析依赖，因此不容易进行静态优化
3.  同步和异步：CJS是同步加载，ESM是异步加载
4.  遵循依赖处理方式不同：ES module采用在编译阶段解决；CommonJS在运行时抛出错误

> &#x20;CommonJS是对模块的浅拷贝，ES6 Module是对模块的引用，即ES6 Module只存只读，不能改变其值，也就不能改变指针，类似与const
>
> import的接口是read-only (只读状态)，不能修改其变量值，即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对CommonJS对重新赋值(改变指针指向)，但是对ES6 Module赋值会编译报错

##### 拓展：两者模块变量的改动

在 CommonJS 中，当你导入一个模块，你实际上得到的是该模块导出对象的一个拷贝。这意味着，如果你在一个模块中改变了一个导入变量的值，这个**改变不会反映到被导入模块中**。

在 ESM 中，`import` 得到的是一个只读引用。对于原始数据类型（如数字、字符串等），你不能改变它们的值。但如果你导入的是**一个对象或数组，你可以改变其属性或元素**。

#### Treeshake如何实现的

`Tree shaking`是基于`ES6`模板语法（`import`与`exports`），主要是借助`ES6`模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量

*   编译阶段利用`ES6 Module`判断哪些模块已经加载
*   判断那些模块和变量未被使用或者引用，进而删除对应代码

#### monorepo的作用和优缺点

Monorepo是一种软件开发实践技术，它将所有相关的代码和**资源存储在同一个代码库**中，而不是将它们拆分为多个独立的代码库。在Monorepo中，所有代码和资源都被视为一个整体，这使得在整个应用程序或项目中重用代码更加容易。此外，Monorepo还使得更好的依赖管理、更好的协作和更好的版本控制成为可能。Monorepo通常用于大型项目或组织中，因为它可以更好地管理复杂的代码库，并使多个开发团队更容易协同工作。

优点：

1.  可以更好地管理依赖项。Monorepo使开发人员能够更轻松地处理依赖项，并确保所有代码和依赖项保持最新状态，从而更容易维护和更新应用程序。
2.  可以更好地共享代码。Monorepo使得开发人员能够更容易地共享代码和资源，并在整个组织中重用代码。这有助于提高代码的可维护性和可重用性，并避免重复编写代码。
3.  可以更好地实现一致性。

缺点：

1.  处理大型代码库可能会变得很困难。随着代码库的增长，Monorepo可能会变得非常大，使得处理和管理代码库变得困难。这可能会导致慢速的构建和部署，以及需要更多硬件和存储资源。
2.  对于多个团队，确保代码质量和可维护性可能会变得更加困难。Monorepo中的所有代码都存储在同一个代码库中，这可能会导致对代码质量和可维护性的严格控制变得更加困难。

#### pnpm、yarn和npm的区别

以下是它们之间的一些主要区别：

1.  **安装方式不同：** NPM 和 Yarn 会在本地项目中创建 node\_modules 文件夹，而 PNPM 将所有软件包安装在全局 .pnpm-store 目录中，并使用符号链接将它们链接到每个项目的 node\_modules 目录中。通过软链接链接到总依赖.pnpm-store
2.  **依赖管理方式不同：** Yarn 和 PNPM 可以并行安装依赖项，而 NPM 只能按照一定的顺序安装。同时，PNPM 还支持 hoisting 功能，这可以将依赖包的公共部分提取到更高级别的依赖层级中
3.  **网络性能：** Yarn 和 PNPM 在网络性能方面比 NPM 更优秀，因为它们使用并行安装和本地缓存来加速包下载和安装。
4.  **版本锁定：** Yarn 通过 yarn.lock 文件锁定软件包版本，而 NPM 通过 package-lock.json 文件锁定版本。PNPM 也有锁定功能，但锁定方式不同。

**yarn** 可以并行下载和缓存软件包和使用 yarn.lock 文件来确保安装过程中使用相同的依赖项版本。

**pnpm** 使用符号链接所有node\_module，可以共享依赖项，更好的内存管理

#### package.json文件的作用

package文件时前端项目的核心配置文件

*   管理依赖项：`package.json` 文件记录了项目所依赖的第三方包及其版本信息。
*   脚本命令：启动、打包
*   版本控制：`package.json` 文件中的 `version` 字段用于记录项目的版本号。
*   项目的信息：包括一些项目元数据：`package.json` 文件中还包含项目的元数据，如项目名称、描述、作者、许可证等

