# 浏览器安全

经典面试题

#### 什么是XSS攻击，如何防御

XSS （Cross-Site Scripting）攻击指的是**跨站脚本攻击**，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

本质是浏览器没有过滤恶意代码，和正常的代码一起执行，导致恶意代码的执行

可以通过以下攻击方式：

*   破坏页面结构，DOM型XSS
*   获取页面数据，如DOM cookie localStorage
*   流量劫持

##### 攻击类型

*   存储型：
    *   攻击者将恶意代码提交到目标网站的数据库中
    *   用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
    *   执行&#x9;
*   反射型：
    *   攻击者构造出特殊的 URL，其中包含恶意代码。
    *   用户点开url，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
    *   用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
    *   恶意代码窃取用户数据并发送到攻击者的网站
*   DOM型：
    *   攻击者构造出特殊的URL
    *   用户打开带有恶意代码的URL
    *   用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行
    *   执行，冒充用户或者给个人信息发送到攻击者网站

##### 如何防御XSS攻击

*   可以从浏览器的执行来进行预防
    *   一种是使用纯前端渲染，不用服务器端拼接后返回 (不使用服务端渲染)。
    *   另一种是对需要插入到 HTML 中的代码做好充分的转义。
    *   对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，在使用html插入代码的`innerHTML、outerHTML、document.wirte()`，不要把不可信的数据作为 HTML 插到页面上
*   其他安全措施是CSP，建立一个外域加载资源的黑名单

##### 纯前端方法是什么

*   改成纯前端渲染，把代码和数据分隔开。
*   对 HTML 做充分转义

##### XSS攻击案例

1.  攻击者发现 `http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&domain=bbbb` 这个 URL 的参数 `uin`、`domain` 未经转义直接输出到 HTML 中。于是攻击者构建出一个 URL，并引导用户去点击。用户点击这个 URL 时，服务端取出 URL 参数，拼接到 HTML 响应中。这样就能窃取域名下的cookie

#### 什么是CSRF攻击和如何防御

是指跨站请求伪造攻击，攻击者诱导用户进入一个**第三方网站**，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

**特点**：利用Cookie的同源请求中携带发送给服务器的特点，来实现用户的**冒充**。

攻击者关键是什么

> 攻击者利用的关键是**受害者的浏览器会自动发送来自已登录网站的身份认证信息**（如cookie），无论请求是来自哪个网站。这使得攻击者能够伪造请求并以受害者的身份发送。

##### 攻击类型

*   get类型的攻击
*   Post类型的攻击
*   链接类型的攻击，诱导用户点击

##### 如何防御CSRF攻击

*   同源检测，在部分与CSRF有关的请求中，请求的Header中会携带Origin字段。如果origin存在，直接使用Origin中的字段确认来源域名；如果没有Origin，阻止访问
*   使用CSRF Token验证，可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开
*   对cookie进行双重验证，
*   在设置cookie属性时设置sameSite，限制cookie不能被第三方使用，使得指定 Cookie 不可以在跨站点请求中发送

#### 有哪些前端安全问题

*   跨站脚本 XSS
*   iframe的页面
*   跨站点的请求伪造 CSRF（cross-site request forgieriss）
*   SQL注入
*   文件上传注入
*   中间人欺骗
*   ARP欺骗

#### 一个URL包括什么

*   协议
*   主机名 （host）
*   端口号
*   路径
*   查询字符串
*   片段标识符

### 在浏览器地址栏输入一个 URL 后回车，背后发生了什么

可以分成六步<https://juejin.cn/post/6844904054074654728#heading-5>

**合成url**

用户输入URL， 浏览器会根据用户输入的信息判断是搜索还网站；如果是网址，浏览器根据URL协议，在这段内容上加上协议合成合法的URL。

#### 查找浏览器缓存

##### DNS域名解析

*   浏览器会检查URL中的域名并向DNS服务器发起请求以获取与该域名对应的IP地址。如果DNS缓存中已有该信息，浏览器将直接使用该信息
*   DNS域名查找，在客户端，浏览器和本地DNS之间递归查询；在本地DNS服务器与根域及其子域之间的查询方式是迭代查询
*   ![GitHub](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/30/16ff45eedca06afb\~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)
*   会有一个递归查找的过程，从浏览器缓存中查找->本地的hosts文件查找->找本地DNS解析器缓存查找->本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。
*   迭代模式是从客户端---本地DNS服务器---根域名服务器---顶级域名服务器---权威域名服务器

##### 建立TCP连接

*   首先判断是否是https，如果是，则HTTP+SSL/TLS两个部分，在HTTP基础上有加了一层处理加密信息的模板
*   进行三次握手，建立TCP连接。
    1.  建立连接。客户端发送连接请求报文段SYN，之后客户端处于`STN-SENT`
    2.  服务器收到SYN报文段，将报文处理后发送给客户端
    3.  客户端收到服务器的SYN+ACK报文段，将Acknowledgment Number设置为y+1，向服务器发送ACK报文段

##### 发送HTTP情求，服务器处理情求，返回回响应结果

*   TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求
*   发生了HTTP缓存

##### 关闭TCP连接，四次挥手

*   四次挥手关闭TCP连接
*   第一次挥手：客户端发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文
*   第二次挥手：服务端收到该报文后，就向客户端发送 `ACK` 应答报文
*   第三次挥手 等待服务端处理完数据，向客户端发送`FIN`报文
*   第四次挥手：客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文
*   服务端收到ack报文，进入close状态，服务器断开连接
*   客户端经过一些时间 进入close状态，断开连接

##### **浏览器渲染**

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305.png?x-oss-process=image%2Fresize%2Cw_663%2Climit_0)

*   浏览器会将 HTML 解析成一个 `DOM 树`，DOM 树的构建过程是一个`深度遍历`过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
*   将 CSS 解析成 `CSS Rule Tree`（css 规则树）。
*   解析完成后，浏览器引擎会根据 `DOM 树`和 `CSS 规则树`来构造 `Render Tree`。（注意：Render Tree 渲染树并不等同于 DOM 树，因为一些像 `Header` 或 `display:none` 的东西就没必要放在渲染树中了。）
*   有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的`从属关系`。
*   &#x20;`layout`(布局)，进入布局处理阶段，即**计算出每个节点在屏幕中的位置**。
*   最后一个步骤就是`绘制`，即遍历 RenderTree，层绘制每个节点。根据计算好的信息绘制整个页面。

#### 浏览器如何渲染页面的过程

如上\:top:​

#### CSS中样式是如何解析的

1.  获取CSS文件，当浏览器解析HTML文件时，会与到\<link>标签或`<style>`标签，它们用于引入外部CSS文件或内嵌样式表
2.  构建CSS对象模型 CSSOM
3.  匹配元素，遍历DOM树的每个节点，匹配每个元素的CSS规则
4.  计算样式：匹配到CSS元素应用到相应的元素上
5.  布局：计算样式后，浏览器会根据元素的样式属性（如宽度、高度、定位等）确定每个元素在页面中的位置和大小
6.  绘制：浏览器会将每个元素按照其样式属性进行绘制，将它们渲染到屏幕上
7.  展示

#### CSS解析的顺序是什么

1.  收集样式规则，包括\<link>\<style>外部文件
2.  解析样式规则
3.  匹配元素和选择器：
4.  计算样式

#### 浏览器缓存的全过程

1.  检查缓存是否过期，如果没有过期从缓存读取数据；过期，向服务器发送请求Etag和Last-modified，缓存是否更新
2.  服务器收到请求后，优先根据 `Etag` 的值判断被请求的文件有没有做修改
    1.  如果一致则没有修改，协商缓存，返回 304;
    2.  如果不一致则有改动，直接返回新的资源文件带上新的 `Etag` 值并返回 200
3.  如果服务器收到的请求没有`Etag` 值，则将`if-Modified-Since` 和`if-None-Match`被请求文件的最后修改时间做比对，
    1.  一致则命中协商缓存，返回 304;
    2.  不一致则返回新的 last-modified 和文件并返回 200

#### 谈谈对浏览器强缓存和协商缓存

浏览器缓存是指浏览器在本地存储用户最近请求过的资源，例如网页、图片、样式表、脚本等。当用户再次访问同一网站时，浏览器可以直接从本地缓存中加载这些资源，从而提高网页的加载速度和用户的体验。

浏览器缓存分为两种：强缓存和协商缓存。

**强缓存**

是指浏览器直接从本地缓存中加载资源，而不向服务器发送请求。浏览器会在第一次请求资源时，根据响应头中的**Expires和Cache-Control**字段判断资源是否过期。如果没有过期，则直接从本地缓存中加载资源；如果过期了，则向服务器发送请求。

**协商缓存**

是在缓存过期的情况下，客户端和服务端协商，确认客户端缓存是否需要更新。根据响应头的

命中协商缓存是条件是**max-age和no-store**

```xml
是指浏览器向服务器发送请求，但是服务器不会直接返回资源。而是根据请求头中的if-modified-since和if-none-match字段判断资源是否更新。如果没有更新，服务器返回304请状态码，告诉浏览器可以直接从本地缓存中加载资源，如果有更新，则服务器返回新的资源。
```

协商缓存是通过两种方式设置，

第一种：请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现：

*   响应头部中的 `Last-Modified`：标示这个~~响应~~资源的最后修改时间；
*   请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified）

第二种：请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段，这两个字段的意思是：

1.  响应头部中 `Etag`：唯一标识响应资源；
2.  Etag，服务器返回资源时，在头信息添加Etag属性，是资源唯一标识符。在下次请求资源时，浏览器会在请求头中添加`if-none-match`属性，属性值返回上面的Etag值。将这两个进行比较判断资源是否发生变化。

#### Etag有什么缺点

服务器需要考虑负载平衡问题，考虑到负载问题，尽量不使用Etag

#### Etag的优点

last-modifed是基于时间实现的，etag是基于一个唯一标识实现的，相对来说后者更加准确判断文件内容是不是发生变化

#### Etag解决了last-modified的什么难点

*   唯一标识符，在没有修改文件内容下可能修改了文件时间，这样etag能监控到
*   文件在秒级以内是能修改的，etag能监控到一秒内修改的

#### 强缓存支不支持离线

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求，支持离线的。

###### 如何禁止强缓存

*   cache-control：设置字段no-store
*   Expire：头部可以设置一个过去的日期和时间，以指示响应已过期

#### 协商缓存的触发开始

当过期了max-age和no-store时，才触发

通过两种触发方式来设置，分别是http中的**Etag**和**Last-Modified**

#### 为什么需要缓存

缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略

*   缩短网页请求资源的距离，减少延迟
*   由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷

#### cache-control有哪些值

*   no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存
*   no-store： 表示客户端禁止任何缓存，每次向服务端发起请求，拉去最新资源

#### **对前端路由的理解**

一个url对应一个页面，跳转总是伴随着刷新，体验不好。后来出现了AJAx，在不刷新页面的情况发出请求，所以出现了SPA

#### **SPA的理解**

全称单页面应用程序。在单页面应用程序中，不用为每个路径创建多个HTML文件，而是使用 避免页面之间切换来打断用户体验、局部刷新、增强用户体验

SPA单页面应用，他允许在不刷新的情况下更新页面内容，使内容更加流畅。在起初 没有考虑到定位问题，不知道进展到哪步

#### 前端路由

所以有了前端路由的观念，前端路由记住一个url下，记住用户走到那一步，是SPA的各个视图匹配唯一的标识。

*   实现需要两步，刷新时，浏览器会默认根据当前url对资源进行重新定位发送请求。

> 当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位(发送请求)。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录 单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢?
>
> 从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢?作为前端，可以提供这样的解决思路: 拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉感知 URL 的变化。这里不是说要改造 URL、凭空制造出 个 URL 来而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理一一这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用JS 去给它生成不同的内容。

#### **浏览器渲染**

主要有以下步骤

*   解析收到的文档，根据文档构建DOM树，DOM树是由DOM元素及属性接节点组成
*   解析CSS 生成 CSS规则树
*   根据DOM树和规则树构建渲染树，渲染树的节点称为渲染对象
*   当渲染对象被创建并添加到树中，它们并没有位置，所以当浏览器⽣成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。
*   布局结束是绘制阶段，遍历渲染树并调用对象的paint方法将他们显示在屏幕上，绘制使用UI组件。

#### **浏览器渲染优化**

1.  针对JS  JS文件对阻塞HTML解析，在JS的加载上进行改变

*   将JS文件放在body后面
*   body中间不写script
*   script引入资源方式有三种
    *   script ⽴即停⽌⻚⾯渲染去加载资源⽂件，当资源加载完毕后⽴即执⾏JS代码，JS代码执⾏完毕后继 续渲染⻚⾯
    *   async在下载完 立即异步加载 加载好立即执行
    *   defer：在下载完后，立即异步加载。加载好后，先等DOM树解析好执行；

针对CSS：尽量使用link预加载和GUI渲染进程会继续向下渲染代码

针对DOM树、CSSOM树：

减少回流与重绘：

#### 渲染过程中遇到 JS 文件如何处理?

建议把script标签放在body标签底部

#### JS卡死阻塞UI渲染怎么办

*   优化JS代码，检查代码中是否存在长时间运行或复杂的循环。
*   异步操作：将长时间运行的任务转换为异步操作，以避免阻塞UI线程。可以使用Web Workers或Promise等技术
*   分批处理：使用定时器或requestAnimationFrame等方法分割任务
*   使用WebWork：将耗时的计算任务转移到Web Worker中，以在后台线程中进行处理，避免阻塞UI线程

#### Cookie有哪些属性

*   Name
*   value
*   Size
*   Path
*   Secure
*   Domain
*   HTTP

#### 如何保证cookie的安全性

1.  使用 Secure 标记：通过在设置 Cookie 时添加 `Secure` 标记，限制仅在通过 HTTPS 连接时才发送 Cookie。这可以防止在不安全的网络连接中传输 Cookie。
2.  使用 HttpOnly 标记：通过在设置 Cookie 时添加 `HttpOnly` 标记，限制 JavaScript 访问 Cookie。这可以防止跨站点脚本攻击（XSS），因为攻击者无法通过恶意脚本访问或窃取 Cookie。
3.  使用 HTTP 头部控制 Cookie：通过使用 `Set-Cookie` 头部来设置 Cookie，并使用适当的属性和选项来控制 Cookie 的行为。例如，可以使用 `SameSite` 属性来限制 Cookie 的跨站点传输，并使用 `Domain` 和 `Path` 属性来限制 Cookie 的作用域。

#### 浏览器本地存储

#### Cookie LocalStorage SessionStorage

**Cookie** 是最早提出的本地存储方式，**每次发送HTTP请求会携带Cookie**，大小最大**4kb**，Cookie每次HTTP请求被携带

特性：

*   Cookie是无法跨域名的，两个域名下是无法共享，阻止网站获取cookie

最常见的使用场号就是Cookie和session结合使用，携带sessionld，这样服务端就知道是谁发起的请求，从而响应相应的信息我们将sessionld存储到Cookie中，每次发请求都会携带这响应的信息。

##### LocalStorage

是HTML5新引入的特性，存储量够大

*   大小最大有**5Mb** 可以存储更多信息
*   是持久存储，<u>除非主动清理，不然会永久存在</u>
*   仅存在本地存储，不像Cookie每次HTTP请求被携带
*   缺点是存在浏览器兼容，受到同源策略的限制，集端口，协议 主机有任何一个不同，都不会访问

使用场景

*   网站换肤，将皮肤放在localStorage
*   网站的 密码个人信息账号登录

##### SessionStorage

SessionStorage主要⽤于临时保存同⼀窗⼝(或标签⻚)的数据，刷新⻚⾯时不会删除，关闭窗⼝或标签⻚之后将会删除这些数据。

*   和localStorage相比，都会进行本地存储，<u>单页面关闭时失效</u>
*   有同源策略的限制，有一条特殊的限制，只有在**同一浏览器的同一窗口**下才能共享
*   不能被爬虫爬取

使用场景

*   讲究一个时效性，游客信息保存，离开后删除。

#### Cookie的安全规范

*   不放重要数据，重要数据放Session。我们已经知道 Cookie 不安全了，就不要作死非把重要数据放在 Cookie 里了
*   Cookie 数据加签名。对Cookie加签名买服务器可以识别
*   cookie数据加密。加密的过程非常消耗性能
*   全站的Https+Cookie secure设置
*   设置更小作用域的Cookie，尽可能给cookie设置合适且小的作用域

#### Cookie和token的区别

*   Cookie 验证是服务器在用户登录时生成 用户唯一标识 即 Sessionid 并以映射表的形式保存在该台服务器的内存上，将该 Sessionid 通过set-cookie头部传给客户端浏览器保存到cookie，下次同源请求浏览器自动带上sessionid
*   token 如下 拓展性比较强，
    *   token认证不局限于cookie
    *   不使用cookie就可以规避CSRF攻击。比较安全
    *   token不需要存储

#### cookie和sessionId的区别

HTTP是无状态协议，Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。

*   Cookie 当用户首次访问一个网站时，服务器可以通过在响应中设置一个名为"Set-Cookie"的HTTP标头来发送一个Cookie到客户端
*   Session ID（会话标识符）是一种服务器端的机制，用于跟踪用户会话。当用户首次访问一个网站时，服务器会为该用户创建一个唯一的Session ID，并将其存储在服务器上的会话管理器中
*   Cookie是在**客户端存储**的数据，用于在不同的会话之间跟踪用户，而Session ID是**服务器端**生成的唯一标识符，用于在服务器上跟踪用户会话并存储相关数据。

#### Token存放在哪，存在cookie和localstorage有什么区别，为什么不存在cookie

##### Token可以存在Cookie和localStorage

*   Token可以存储在Cookie中。当浏览器向服务器发送请求时，会自动将存储在Cookie中的Token发送给服务器。使用Cookie存储Token的优点是，Token会自动随着请求发送给服务器，无需在每次请求时手动添加。然而，使用Cookie存储Token存在一些安全风险，例如Cookie可能会被窃取或伪造，导致身份被盗用。
*   Token也可以存储在LocalStorage中。LocalStorage是HTML5提供的一种本地存储机制，可以将数据存储在客户端浏览器中。使用LocalStorage存储Token的优点是，相对于Cookie，LocalStorage存储更为安全，不会被浏览器自动发送给服务器，而且LocalStorage具有更大的存储容量。

##### 为什么不存在cookie

*   尽管可以使用Cookie存储Token，但是在某些情况下，例如在开发RESTful API时，可能希望Token不被存储在Cookie中，而是存储在请求头或者请求体中。这是因为，在某些情况下，Cookie可能会被窃取或伪造，导致安全风险。
*   另外，如果使用Cookie存储Token，则每次请求时都会将Token自动发送给服务器，这可能会导致性能问题。因此，在某些情况下，<u>开发人员可能更愿意将Token存储在请求头或者请求体中。</u>

`sessionStorage`在同域下的多窗口之间能共享状态

**多窗口之间**sessionStorage不可以共享状态！！！但是在某些特定场景下新开的页面会复制之前页面的sessionStorage

*   在该标签或窗口打开一个新页面时会复制顶级浏览会话的上下文作为新会话的上下文
*   换言之就是，在本页面中一标签或窗口打开的同源会临时共享之前页面的`sessionStorage`

##### token cookie localStorage sessionStrorage分别存在哪里

*   token是存储在客户端的内存，通常在内存中短暂存在
*   cookie是存储到客户端的内存
*   `localStorage` 存储在浏览器的本地存储区域
*   `sessionStorage` 存储在浏览器的本地存储区域

#### session和jwt的区别

*   保存位置，session是保存在服务端，jwt是保存在客户端
*   安全性：jwt没有加密，session是存储在服务端，相对安全
*   **两者长度**: jwt太长，cookie的限制大小一般是4kb，cookie很可能放不下，所以iwt一般放在localStorage里面，而sessionld只是很短的一个字符串，因此使用jwt的http请求比使用session的开销大得多
*   **实用性**： jwt的何在可以存储一些常用信息，用于数据交换

#### Session

客户端向服务端发起请求时，服务端会开辟一块内存空间，这个对象就是session对象。

##### Session如何判断是否是同一个会话

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399d7970b6\~tplv-t2oaga2asx-jj-mark:3024:0:0:0\:q75.awebp)

接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。

#### 如果token和缓存被删除，那可以使用什么方法保存

可以使用indexDB，indexdb必须要手动清除才能删除。清缓存和删token都不影响。

*   indexDB 是浏览器提供的一种本地数据库，允许你在浏览器中存储和检索结构化数据。

*   可以存储大量数据，提供接口来查询，还可以建立索引，这些都是其他存储方案无法提供的能力。

#### 浏览器同源策略

同源指的是：是一种安全机制，它是为了防止一个网站的恶意脚本访问另一个网站的数据而实施的。同源策略要求网页文档或脚本只能与其所属源  协议、端⼝号、域名必须⼀致protocol（协议）、domain（域名）、port（端⼝）（三者必须⼀致，包括协议、主机名和端口）相同的资源进行交互，否则将受到浏览器的限制

限制了三个方面

*   当前JS脚本不能访问其他域下的cookie localStorage indexDB

#### **解决跨域问题**

##### 跨域

> 跨域指的是浏览器不能执行其它网站的脚本。是由浏览器的同源策略造成的，是浏览器对JavaScript 施加的安全限制。同源策略也会对开发者造成一定的限制，需要采用一些技术手段来绕过这些限制

当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问就会遇到跨域问题。

**CORS**  &#x20;

> 全称Cross-Origin Resource Sharing，主流的浏览器都支持**CORS**方式。

跨域资源共享是一种web标准，定义了浏览器在跨域的情况进行数据交换。 他使用==额外的自定义的HTTP都来告诉浏览器让运行==在origin（domain）上的web应用被准访问来自不同资源服务器的指定的资源。

CORS需要浏览器和**服务器**同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信。

*   **在被跨域的服务端设置响应头来允许跨域请求，至少的设置`Access-Control-Allow-Origin`**

简单请求：

> 浏览器发送一个CORS请求，会再请求头添加一个**Origin**字段，说明本次字段来自哪个源，服务器会根据值决定是否同意这次请求。
>
> 服务端至少的设置`Access-Control-Allow-Origin`，还有一些属性值是`Access-Control-Allow-Method, Access-Control-max-age,Access-Control-Allow-head`
>
> 前端也可以设置cors

**JSONP**

**jsonp**的原理是利用`<srcipt>`标签<u>没有跨域限制</u>，通过`<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回浏览器，浏览器解析执行，从而前端拿到callback函数返回接口的数据。

由于这个回调函数实在同域下执行的，因此就解决了<u>跨域问题</u>

jsonp的缺点：具有局限性，仅支持get方法；不安全，会受到XSS攻击

**postMessage跨域**

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的windows属性之一，它可用于解决以下方面的问题：

*   页面和其他打开的新窗口的数据传递
*   多窗口之间消息传递
*   页面与嵌套的iframe消息传递

用法：postMessage（data，origin）方法接受两个参数；

*   data html5规范支持任意基本类型的对象
*   origin 协议+主机+端口号，也可以设置成“\*”，表示传递给任意窗口，如果要指定和当前窗口同源的话设置成 ‘/’

##### nginx代理跨域

Nginx代理跨域，实质上和CORS跨域原理一样，通过配置文件**设置请求响应头**Access-Control-Allow-Origin  等字段，

1.  nginx配置解决iconfont跨域   浏览器访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件
2.  nginx反向代理借口跨域   同源策略仅是针对浏览器的安全策略。服务器端调用HTTP借口知识使用HTTP协议，不需要同源策略，也就不存在跨域问题

##### Vue框架的跨域 node中间件代理

采用node+vue+webpack+webpack-dev-serve搭建项目，直接修改webpcak.config.js配置。开发下vue页面的渲染和接口代理服务器是同一个，不需要跨域

使用proxy：

```js
module.exports = {
devServer: {
        publicPath: Setting.publicPath,
        proxy: {
            '/api': {
                // 转发后台地址，解决跨域问题
                target: 'http://www.domain2.com:8080'
                nv.VUE_APP_BASE_API,
                changeOrigin: true
            },
        }
}
```

#### 跨域请求中，如何传递cookie？

在后端设置

1.  在前端请求的时候设置request对象的属性`withCredentials`为true
2.  在服务端设置`Access-Control-Allow-Origin`
3.  在服务端设置`Access-Control-Allow-Credential`

#### 浏览器通信的方法

1.  HTTP get post
2.  WebSocket：WebSocket是一种在单个TCP连接上进行全双工通信的网络协议，能够实现客户端和服务器端的实时双向通信。
3.  fetch API：fetch API是一种替代XHR对象的新一代网络请求API，使用起来更加简单和方便，支持Promise和async/await语法。
4.  基于XMLHttpRequest（XHR）对象的传统AJAX请求：这是一种在后台向服务器发送异步HTTP请求的方式，可以实现在不刷新页面的情况下获取服务器数据并动态更新页面。

#### JSON Web Token是什么 <http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html>

JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案

JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，类*似一个map*

*以后服务端和客户端通信时，都要发送这个JSON对象，服务器只靠这个对象认定用*户身份。

```js
{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2018年7月1日0点0分"
}
```

JWT的构成： 第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).

*   头部是经过base64加密处理的，有两个部分 声明类型和加密算法
*   载荷是存放有效信息的地方
*   signature第三部分是一个签证信息  包括header payload  secret

#### 使用方式

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

#### JWT的几个特点

*   **无状态**，相比于传统基于会话（Session）的身份验证方式，JWT是无状态的，服务器不需要在后端存储会话信息，仅需验证签名即可确认身份
*   **可跨域**
*   **安全性高**
*   **无法处理会话管理**：与基于会话（Session）的方式相比，JWT无法直接处理复杂的会话管理需求，如跟踪会话状态、注销会话等
*   **无法实时更新**：JWT令牌的有效期一旦过期，需要重新进行身份验证和授权，无法实时更新令牌的有效性。

#### Token里面具体内容

登录验证时的Token是一个用于**身份验证和授权的令牌**，它通常是一个字符串，包含了一些特定的信息。包括以下信息

*   用户标识（User Identifier）：Token中会包含标识用户的信息，如用户ID、用户名或邮箱等
*   有效期（Expiration）：Token中会包含一个过期时间
*   签名（Signature）：为了确保Token的安全性和完整性，Token中通常包含一个签名部分

#### TOKEN如何生成

在浏览器中，token 通常指的是身份验证 token，也称为令牌或访问令牌。身份验证 token 是用于验证用户身份的一种方式，通常包含加密信息和过期时间等元数据，可以在用户登录后生成并保存在浏览器中，以便在后续的请求中使用。

身份验证 token 的生成方式通常由服务器端实现，可以分为以下几个步骤：

*   用户登录：用户在浏览器中输入用户名和密码，并提交给服务器进行验证
*   服务器验证：服务器接收到用户提交的用户名和密码，进行验证。如果验证成功，服务器会生成一个随机字符串或者使用算法生成一个唯一的 token，并将 token 返回给浏览器
*   浏览器保存：浏览器接收到服务器返回的 token 后，保存在cookie或者localStorage
*   后续请求：用户在后续的请求中携带 token，例如在请求头中添加 Authorization 字段，服务器在接收到请求时，会从请求中获取 token 并进行验证。验证成功就继续处理情求

#### 用户鉴权的token为什么你要放在localStorage 不放在cookie

1.  存储在localStorage 中，每次调用接口的时候都把它当成一个字段传给后台

2.  拿到之后存储在localStorage中，每次调用接口的时候放在HTTP请求头的Authorization字段里所以token在客户端一般存放于localStorage，cookie，或 sessionStorage中

3.  **安全性** localStorage 是浏览器本地存储安全性更高，不会随着 HTTP 请求发送到服务器端，因此减少了 CSRF 攻击和 XSS 攻击的风险。而 cookie 存在于 HTTP 请求头中，容易被窃取和篡改，因此安全性相对较低

4.  **时效性** token存在时效的，一般设置短时间，需要破解密钥。重点在于秘钥

***

**Axios**

是一个基于promise网络请求库，作用于node.js和浏览器中。在服务端它使用原生 node.js和`http` 模块, 而在客户端 (浏览端) 则使用 `XMLHttpRequests`。

*   支持从浏览器中创建XMLHttpRequests
*   能在node.js中发送请求
*   支持promise API

发起一个`post`请求

```js
axios.post('/user', {
    fisrtName: 'Fred',
    lastName: 'Fli'
})
.then((response) => {
    console.log(response);
  })
.catch((error) => {
    console.log(error);
  });
```

发起多个并发请求

```js
function getUserAccount() {
    return axios.get('/user/12345')
}
function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}
Promise.all([getUserAccount(), getUserPermissions()])
.then( (results) => {
    const acct = results[0]
    const perm = results[1]
})
```

```js
axios.all([
    axios.get('http://123.207.32.32:8000/home/multidata', { params: { type: 'pop', page: 1 } }),
    axios({ url: 'http://123.207.32.32:8000/home/multidata', params: { type: 'pop', page: 1 } })
]).then(res => {
    console.log(res) // 返回的是数组包裹的响应信息[res1,res2]
}).catch(err=>{
    console.log(err)
})
```

如何封装Axios

封装一个ajax请求

要封装一个 AJAX 请求，你可以创建一个独立的模块或者工具类，以便在应用程序的各个部分中重复使用。以下是一个基本的示例，展示了如何使用 Promise 和原生 JavaScript XMLHttpRequest 对象封装一个简单的 AJAX 请求：

```js
function ajaxRequest(url, method, data) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.open(method, url, true);

    xhr.onload = function () {
      if (xhr.status >= 200 && xhr.status < 400) {
        resolve(xhr.response);
      } else {
        reject(new Error(xhr.statusText));
      }
    };

    xhr.onerror = function () {
      reject(new Error('Network Error'));
    };

    xhr.send(data);
  });
}

// 示例使用
ajaxRequest('https://api.example.com/data', 'GET')
  .then(response => {
    console.log('请求成功', response);
    // 处理响应数据
  })
  .catch(error => {
    console.error('请求失败', error);
    // 处理错误
  });
```

在上述示例中，`ajaxRequest()` 函数接受三个参数：URL、HTTP 方法（例如 GET、POST 等）和要发送的数据（可选）。函数返回一个 Promise 对象，用于处理 AJAX 请求的成功和失败。

在函数内部，首先创建了一个 XMLHttpRequest 对象 `xhr`，使用 `open()` 方法设置请求的URL和方法。然后，通过设置 `onload` 和 `onerror` 事件处理程序来监听请求的成功和失败。`onload` 事件在请求成功时触发，返回状态码在200到 399 之间的响应。`onerror` 事件在网络错误或请求失败时触发。

最后，使用 `send()` 方法发送请求，并在 Promise 中根据请求的结果调用 `resolve`(`)` 或 `reject()`，将响应数据传递给 `then()` 或 `catch()` 方法进行处理。

#### 垃圾回收

**垃圾回收算法：就是垃圾收集器按照固定的时间间隔，周期性地寻找那些不再使用的变量，然后将其清楚或释放内存**

**标记清除法**

1.  标记阶段，依次遍历堆对象，分别给他们打上标记。在代码执行后，取消标记。
2.  清除阶段  这个阶段再把标记的内存进行整体清除，从而释放内存
    1.  清理所有带有标记的变量，销毁并回收它们所占用的内存空间
    2.  最后垃圾回收程序做一次内存清理

**引用计数法**

1.  不常见的方法，思路是对每个值记录其引用次数

**标记整理**

1.  经过标记清除法后，老生代中产生了大量的内存碎片，会对内存造成影响
2.  特点是：标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。

以上的方法或或少存在一些问题，在v8中，对垃圾回收做了优化

**分代式垃圾回收**

回收策略是分代式垃圾回收机制，v8中将堆内存分成新生代和老生代

**V8采用两个垃圾回收器来管控**

*   *新生代空间中*，内存空间分两部分，分别是From和To空间。在两个空间中，有一个是空闲的。新分配的对象会被放入From空间，当From空间放满，新生代GC算法启动。
    *   检查是否有From空间存活的对象并复制到To空间，如果有失活则销毁。
    *   当复制完成将From空间和To空间互换，GC就结束了
*   *老生代算法*，使用了两种算法，清除标记法 标识压缩算法
    *   以下情况对象会出现在老生代空间中
        *   新生代的对象是否已经经历过Scavenge算法，如果有，将对象从新-->老
        *   To空间的占比超过25% 为了不影响内存分配，将对象从新--->老

#### **内存泄漏**

##### **什么是内存泄漏**

内存泄漏（Memory Leak）是指在计算机程序中，由于错误的内存管理导致未使用的内存无法被释放或回收，进而导致系统内存资源的浪费和耗尽的现象。

##### **哪些操作会造成内存泄漏**

*   不合理使用闭包，导致某些变量遗留在内存中
*   **太多无用的DOM引用** 获取DOM元素的引用，后面吧他删除，一直保存这元素的引用
*   **定时器或回调太多**，设置setInterval定时器，而忘记取消它；如果函数有对外的引用，变量会一直保存在内存中。
*   使用未声明的变量

##### 防止内存泄漏

*   如果是新建map，尽量使用`WeakMap和WeakSet`，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内
*   比如Vue的页面设置了监听，切换页面时没有destory()
    *   可以适用`destory()`清除

##### **如何查看泄露情况**

*   调试器：使用调试器可以帮助你跟踪程序的执行过程，定位可能的内存泄漏点。通过设置断点、观察变量跟踪内存分配和释放的调用堆栈，可以找到潜在的内存泄漏问题
*   日志记录：在代码中添加日志记录，可以帮助你追踪内存分配和释放的情况
*   内存分析工具：使用专门的内存分析工具可以帮助你检测内存泄漏

#### 前端性能指标

前端性能监控的API：performance下面有什么

*   memory(内存)：可以获得当前页面的内存使用情况
*   navigtor： 可以获得当前页面的进入方式，重定向次数等信息
*   timing（网络请求，页面解析等核心）

##### 基于Performance输出简单的性能指标

LCP FID CLS

DCL（DOM Content Loaded）：HTML加载完成时间

LCP （Largest Contentful Paint）：根据页面开始加载的时间报告可视区域内可见的最大图像或文本块完成渲染的计算时间

FCP（First Content Paint）:测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。

计算方法都可以通过PerformanceObserver 埋点的方式。

#### LCP时间怎么计算？

> LCP 指标代表的是视窗最大可见图片或者文本块的渲染时间。

1.  基于PerformanceObserver&#x20;

```javascript
new PerformanceObserver((entryList) => {  
    for (const entry of entryList.getEntries()) {  
        // entry.startTime 的值即为LCP 
    }  
}).observe({type: 'largest-contentful-paint', buffered: true});
```

1.  基于web-vitals

```javascript
import {onLCP} from 'web-vitals';
console.log(onLCP)
```

#### 浏览器性能指标如何查看

*   在开发者工具的 "性能" 或 "Performance" 面板中，你可以记录和分析页面加载时间、资源加载时间、JavaScript 执行时间等性能指标。
    *   查看快照：页面的每秒帧数，`CPU`的消耗和各种请求花费的时间和加载、脚本执行、渲染、绘制
*   Lighthouse：Lighthouse 是一个开源的自动化工具，可用于评估网页的性能、可访问性、最佳实践等方面&#x20;

#### Summary（性能摘要）

Loading ：加载时间\
Scripting ：js计算时间\
Rendering ：渲染时间\
Painting ：绘制时间\
Other ：其他时间\
Idle ：浏览器闲置时间

#### 在实践中，代码从执行到渲染结束，有哪些是消耗时间的

*   Event(click) : `40.84ms`
*   Recalculate Style : `105.08ms`
*   Layout : `731.56ms`
*   Update Layer Tree : `58.87ms`
*   Paint : `15.32ms`

有以上的耗时部分，像样式计算（Recalculate Style）和布局（layout）阶段回消耗大量时间
